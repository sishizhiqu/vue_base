<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2_vue的基本使用</title>
</head>
<body>
    <div id="app">
        <!-- 这个挂载点一旦被vm挂载，那么内部就不是单纯的html，被称作模板 -->
        <!-- 模板是由两部分组成  : html + js -->
        <!-- 模板的语法 : 指令和插值 -->
            <!-- 指令: 用来修改模板当中标签(属性 内容 样式) -->
            <!-- 插值: 专门用来修改模板当中标签的内容的 {{}} -->

        <p>{{msg}}</p>
        <p>{{msg.toUpperCase()}}</p>
    </div>
    <script type="text/javascript" src="./js/vue2.js"></script>
    <script type="text/javascript" >
        //1.引入vue.js
        //2.在body当中必须写一个挂载点
        //3.实例化一个Vue的实例化对象，和挂载点进行挂载
        //4.请求获取回来的数据,是配置对象当中的data

            //函数首先是函数，也是函数对象
            //函数可以当函数用（），也可以当对象用  函数.属性
            //函数当函数可以有多种用法：
                //1. 普通函数调用  （）                this --> window ; 严格模式： undefined
                //2. 构造函数调用   new + （）         this --> 实例化对象
                //3. 方法          a.b()              this --> 调用方法的对象
                //4. 回调函数       自己不用，系统调用  this --> 如果是事件回调，指向事件源
                //5. call apply    让一个对象借用另外一个对象的方法   this -->  传的参
                //6. 箭头函数                          this --> 代表外层执行上下文的this
        
        const vm = new Vue({
            el:'#app',  //挂载点，本质上是一个css的选择器字符串，标识着vm要和谁去绑定挂载
            data: {
                msg: 'i love you',
            }
        })

        //vm对象和传递的配置对象不是同一个对象
        //数据代理：使用vm代理了配置对象当中的数据，vm身上也有和data种同名的属性，模板当中访问的数据都是vm身上的属性
        //vm代理了data当中的数据，找vm获取数据其实最终还是拿的data中的属性值
        //修改vm的数据其实本质是修改data中的数据
    </script>
</body>
</html>